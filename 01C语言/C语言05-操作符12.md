# 1 移位操作符
```c
<< 左移操作符
>> 右移操作符
注：移位操作符的操作数只能是整数
```

## 1.1 左移操作符
> 左边抛弃、右边补0
![](assets/C语言05-操作符12.png)
## 1.2 右移操作符
> 1. 逻辑移位
左边用0填充，右边丢弃
>2. 算术移位（常用）
左边用原该值的符号位填充，右边丢弃
![](assets/C语言05-操作符12_1.png)
# 2 位操作

| 符号 | 描述 | 运算规则                 |
| ---- | ---- | ------------------------ |
| &    | 按位与   | 两个位都为1时，结果才为1 |
| \|   | 按位或   | 两个位都为0时，结果才为0 |
| ^    | 按位异或 | 两个位相同为0，相异为1   |
注：他们的操作数必须是整数。

## 练习1
> 不能创建临时变量（第三个变量），实现两个数的交换。
```c
#include <stdio.h>
int main()
{
	int a = 10;
	int b = 20;
	a = a^b;
	b = a^b;
	a = a^b;
	printf("a = %d b = %d\n", a, b);
	return 0;
}
```

## 练习2
```c
#include <stdio.h>
int main()
{
	int num = -1;
	int i = 0;
	int count = 0;//计数
	for(i=0; i<32; i++)
	{
		if( 1==((num>>i)&1) )
			count++;
	}
	printf("二进制中1的个数 = %d\n",count);
	return 0;
}
```

# 3 单目操作符
`sizeof`

```c
printf("%d\n", sizeof(a));
printf("%d\n", sizeof(int));
printf("%d\n", sizeof a);//可以
printf("%d\n", sizeof int);//不可以
```
`sizeof` 后面是类型时不可以省略括号。

`~`
```c
int a = 11;
// 00000000 00000000 00000000 00001011
// 将倒数第三位改成1：或1上去
// 00000000 00000000 00000000 00000100
// 00000000 00000000 00000000 00001111

// 00000000 00000000 00000000 00000100 可以是1向左移动两位（1<<2）
a = a|(1<<2); //15


// 00000000 00000000 00000000 00001111 
// 将到时第三位变成0：按位与0
// 11111111 11111111 11111111 11111011
// 00000000 00000000 00000000 00001011

// 11111111 11111111 11111111 11111011可以是00000000 00000000 00000000 00000100 按位取反得到，00000000 00000000 00000000 00000100 可以是1向左移动两位（1<<2）

a = a&(~(1<<2)); //11
```

# 4 逻辑操作符
```c
&& 逻辑与
|| 逻辑或
```

```c
#include <stdio.h>
int main()
{
int i = 0,a=0,b=2,c =3,d=4;
i = a++ && ++b && d++;
//i = a++||++b||d++;
printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
return 0;
}
```

结果： 1 2 3 4
`a++` 先试用后加加，所以 `a++ && ++b && d++` 中 `a++` 为0，`&&` 左边为0 右边不管什么数都为假，不算了 ，所以`++b` 和 `d++` 都没有运算。`a++` 自增后变为1。

```c
#include <stdio.h>
int main()
{
int i = 0,a=1,b=2,c =3,d=4;
i = a++||++b||d++;
printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
return 0;
}
```

结果 2 2 3 4

# 5 逗号表达式
```
exp1, exp2, exp3, …expN
```
逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。

```c
int a = 1;
int b = 2;
int c = (a>b, a=b+10, a, b=a+1);//逗号表达式
```

结果 13

# 6 函数调用操作符( ) 
```c
int get_max(int x,int y)
{
return x>y?x:y;
}

int main()
{
	int a =10;
	int b =20;
	int max = get_max(a,b);
	return 0;
}
```

**调用**函数时候的 `()` 就是函数调用操作符,该函数操作数有三个，为`get_max` `a` `b` 

# 7 访问一个结构的成员

```c
. 结构体.成员名
-> 结构体指针->成员名
```

```c
#include <stdio.h>
struct Stu
{
	char name[10];
	int age;
	char id[20];
}

int main()
{
//使用struct Stu这个类型创建了一个学生对象stu,并初始化
	struct Stu stu = {"张三",20,"20210304"};
	struct Stu* ps = &stu;//结构成员访问

	printf("%s\n",stu.name);
	printf("%s\n",ps->name);
	printf("%s\n",(*ps).name); // 与ps->name相同
return 0;
}
```

# 8 隐式类型转换
C的整型算术运算总是至少以缺省整型类型的精度来进行的。
为了获得这个精度，表达式中的**字符**和**短整型**操作数在使用之前被转换为普通整型，这种转换称为**整型提升**。

如何进行整体提升呢？
> 整形提升是按照变量的数据类型的符号位来提升的

## 负数的整形提升
```c
char c1 = -1;
变量c1的二进制位为：
10000000 00000000 00000000 00000001 原
10000000 00000000 00000000 00000000 反
11111111 11111111 11111111 11111111 补
但字符型c1只有8个比特位，所以截取最后8位：
11111111

因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，符号位即为11111111中的第一位
提升之后的结果是：
11111111111111111111111111111111
```

## 正数的整形提升
```c
//正数的整形提升
char c2 = 1;
变量c2的二进制位(补码)中只有8个比特位：
00000001
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为0
提升之后的结果是：
00000000000000000000000000000001
//无符号整形提升，高位补0
```

## 例子
```c
int main()
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if(a==0xb6)
	printf("a");
	if(b==0xb600)
	printf("b");
	if(c==0xb6000000)
	printf("c");
	return 0;
}
```

输出为 c

实例中的a,b要进行整形提升,但是c不需要整形提升
a,b整形提升之后,变成了负数,所以表达式`a==0xb6` , `b==0xb600` 的结果是假,但是c不发生整形提升,则表
达式`c==0xb6000000` 的结果是真。

# 操作符的属性

复杂表达式的求值有三个影响的因素。
1. 操作符的优先级
2. 操作符的结合性
3. 是否控制求值顺序。
两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

**问题表达式**
```c
//表达式的求值部分由操作符的优先级决定。
a*b + c*d + e*f
```
> 代码在计算的时候，由于*比+的优先级高，只能保证，*的计算是比+早，但是优先级并不
能决定第三个*比第一个+早执行。

所以表达式的计算机顺序就可能是：
```c
a*b
c*d
a*b + c*d
e*f
a*b + c*d + e*f

或者：
a*b
c*d
e*f
a*b + c*d
a*b + c*d + e*f
```

我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。cao