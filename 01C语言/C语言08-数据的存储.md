  本章重点
1. 数据类型详细介绍
2. 整形在内存中的存储：原码、反码、补码
3. 大小端字节序介绍及判断
4. 浮点型在内存中的存储解析

# 1 数据类型介绍
```c
// 基本的内置类型：
char //字符数据类型
short //短整型
int //整形
long //长整型
long long //更长的整形
float //单精度浮点数
double //双精度浮点数
```

**类型的意义：**
1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。
2. 如何看待内存空间的视角。

## 1.1 类型的基本归类

**整形：**
```c
char
unsigned char
signed char
short
unsigned short [int]
signed short [int]
int
unsigned int
signed int
long
unsigned long [int]
signed long [int]
```

**浮点数:**
```c
float
double
```

**构造类型：**
```c
> 数组类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
```

**指针类型:**
```c
int *pi;
char *pc;
float* pf;
void* pv;
```

**空类型：**
```c
void 表示空类型（无类型）
通常应用于函数的返回类型、函数的参数、指针类型。
```

# 2 整形在内存中的存储

# 2.1 原码、反码、补码
计算机中的整数有三种2进制表示方法，即原码、反码和补码。
三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”。
对于数值位正数和负数的表示不同：

**正数** ： 原、反、补码都相同。

**负整数的三种表示方法各不相同：**
> **原码**
> 直接将数值按照正负数的形式翻译成二进制就可以得到原码。

> **反码**
> 将原码的符号位不变，其他位依次按位取反就可以得到反码。

> **补码**
> 反码+1就得到补码。

**对于整形来说：数据存放内存中其实存放的是补码。**

```c
int main()
{
	int a = 20;
	//00000000 00000000 00000000 00010100 - 补码
	//0x00 00 00 14 - 16进制 
	return 0;
}
```

![](assets/C语言08-数据的存储.png)
我们可以看到对于a和b分别存储的是补码。但是我们发现顺序有点不对。
这是又为什么？

## 2.2 大小端介绍
**什么大端小端：**
> 大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
> 
> 小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。


**为什么有大端和小端：**
为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short
型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。
例如：一个16bit 的short 型x ，在内存中的地址为0x0010 ， x 的值为0x1122 ，那么0x11 为高字节， 0x22 为低字节。对于大端模式，就将0x11 放在低地址中，即0x0010 中， 0x22 放在高地址中，即0x0011 中。小端模式，刚好相反。我们常用的X86 结构是小端模式，而KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。