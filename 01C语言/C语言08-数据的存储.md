  本章重点
1. 数据类型详细介绍
2. 整形在内存中的存储：原码、反码、补码
3. 大小端字节序介绍及判断
4. 浮点型在内存中的存储解析

# 1 数据类型介绍
```c
// 基本的内置类型：
char //字符数据类型
short //短整型
int //整形
long //长整型
long long //更长的整形
float //单精度浮点数
double //双精度浮点数
```

**类型的意义：**
1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。
2. 如何看待内存空间的视角。

## 1.1 类型的基本归类

**整形：**
```c
char
unsigned char
signed char
short
unsigned short [int]
signed short [int]
int
unsigned int
signed int
long
unsigned long [int]
signed long [int]
```

**浮点数:**
```c
float
double
```

**构造类型：**
```c
> 数组类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
```

**指针类型:**
```c
int *pi;
char *pc;
float* pf;
void* pv;
```

**空类型：**
```c
void 表示空类型（无类型）
通常应用于函数的返回类型、函数的参数、指针类型。
```

# 2 整形在内存中的存储

# 2.1 原码、反码、补码
计算机中的整数有三种2进制表示方法，即原码、反码和补码。
三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”。
对于数值位正数和负数的表示不同：

**正数** ： 原、反、补码都相同。

**负整数的三种表示方法各不相同：**
> **原码**
> 直接将数值按照正负数的形式翻译成二进制就可以得到原码。

> **反码**
> 将原码的符号位不变，其他位依次按位取反就可以得到反码。

> **补码**
> 反码+1就得到补码。

**对于整形来说：数据存放内存中其实存放的是补码。**

```c
int main()
{
	int a = 20;
	//00000000 00000000 00000000 00010100 - 补码
	//0x00 00 00 14 - 16进制 
	return 0;
}
```

![](assets/C语言08-数据的存储.png)
我们可以看到对于a和b分别存储的是补码。但是我们发现顺序有点不对。
这是又为什么？

## 2.2 大小端介绍
**什么大端小端：**
> 大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
> 
> **小端**（存储）模式，是指数据的**低位**保存在内存的**低地址**中，而数据的**高位**,，保存在内存的**高地址**中。


```c
int a = 20;

// 小端
// 14 00 00 00

// 大端
// 00 00 00 14
```

**为什么有大端和小端：**
这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。

**练习1**
> 请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。

```c
int check_sys()
{
	int a = 1;
	char* p = (char*)&a;
	if (*p ==1)
		return 1;
	else
		return 0;
}

int main()
{
	int ret = check_sys();
	//返回1，小端
	//返回0，大端
	if(ret == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}
```

优化：
```c
int check_sys()
{
	int i = 1;
	char* p = (char*)&a;
	//返回1，小端
	//返回0，大端
	return *p;
}
```

再优化：
```c

int check_sys()
{
	int a = 1;
	return (*(char*)&a);
}
```

**练习2**
```c
//输出什么？
#include <stdio.h>
int main()
{
	char a= -1;
	signed char b=-1;
	unsigned char c=-1;
	printf("a=%d,b=%d,c=%d",a,b,c);
	return 0;
}
```

结果：-1 -1 255

```txt
char a = -1;
10000000 00000000 00000000 00000001 - 原码
11111111 11111111 11111111 11111110 - 反码
11111111 11111111 11111111 11111111 - 补码

因为char是1字节，所以只能存8bit：
11111111

要求打印的类型为int类型（%d），所以需要整形提升：
11111111 11111111 11111111 11111111 - 反码

接着转换成原码打印：
10000000 00000000 00000000 00000001 - 原码

所以，最终结果为-1
```

同理，对于`a` 和`b` 为有符号位整形提升,高位补充符号位。`c` 无符号整形提升，高位补0。

**练习3**
```c
// 代码1
int main()
{
	char a = -128;
	printf("%u\n",a);
	//%d-打印十进制的有符号数字
	//%u-打印十进制的无符号数字
	return 0;
}

// 代码2
#include <stdio.h>
int main()
{
	char a = 128;
	printf("%u\n",a);
	return 0;
}
```

代码1和代码2结果相同。
![](assets/C语言08-数据的存储_D01.png)

![](assets/C语言08-数据的存储_D02.png)


